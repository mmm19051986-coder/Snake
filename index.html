<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>–ó–º–µ–π–∫–∞ –∑–Ω–∞–Ω–∏–π</title>

<style>
body { font-family: Arial, sans-serif; background:#f2f2f2; }

#game-wrapper {
  width: 720px;
  margin: 20px auto;
  background:#fff;
  padding:12px;
  border-radius:12px;
}

h2 { text-align:center; margin:6px 0; }

#editor {
  border:1px solid #ddd;
  padding:10px;
  margin-bottom:10px;
}

label { font-weight:bold; display:block; margin-top:6px; }

textarea, input {
  width:100%;
  margin-top:4px;
}

button {
  margin-top:8px;
  padding:6px 14px;
  cursor:pointer;
}

canvas {
  display:block;
  margin:auto;
  border:2px solid #ddd;
  background:#fdfefe;
}

#progress {
  height:10px;
  background:#ddd;
  margin-top:8px;
  border-radius:5px;
  overflow:hidden;
}
#progress-bar {
  height:100%;
  width:0%;
  background:#4caf50;
}

#feedback {
  text-align:center;
  font-weight:bold;
  min-height:22px;
}
.success { color:green; }
.error { color:#ef6c00; }
.fail { color:#c62828; }
</style>
</head>

<body>

<div id="game-wrapper">
  <h2 id="taskTitle">–°–æ–±–µ—Ä–∏ —Ç–æ–ª—å–∫–æ —Å—É—â–µ—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–µ</h2>

  <!-- –†–ï–î–ê–ö–¢–û–† -->
  <div id="editor">
    <label>–í–æ–ø—Ä–æ—Å / –∑–∞–¥–∞–Ω–∏–µ</label>
    <input id="taskInput" value="–°–æ–±–µ—Ä–∏ —Ç–æ–ª—å–∫–æ —Å—É—â–µ—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–µ">

    <label>–ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ —Å–ª–æ–≤–∞ (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é)</label>
    <textarea id="correctInput">—Å—Ç–æ–ª, –¥–æ–º, –æ–∫–Ω–æ, –∫–Ω–∏–≥–∞</textarea>

    <label>–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ —Å–ª–æ–≤–∞</label>
    <textarea id="wrongInput">–±–µ–∂–∞—Ç—å, –∫—Ä–∞—Å–∏–≤—ã–π, –≤–∞–∂–Ω—ã–π</textarea>

    <button id="startBtn">‚ñ∂ –ò–≥—Ä–∞—Ç—å</button>
  </div>

  <canvas id="gameCanvas" width="600" height="400"></canvas>

  <div id="progress"><div id="progress-bar"></div></div>
  <div id="feedback"></div>
</div>

<script>
/* =====================
   –ù–ê–°–¢–†–û–ô–ö–ò
===================== */

const MOVE_SPEED = 1.2;          // ‚¨Ö –ú–ï–î–õ–ï–ù–ù–û –∏ –∫–æ–º—Ñ–æ—Ä—Ç–Ω–æ
const SEGMENT_STEP = 10;
const REQUIRED = 6;
const MIN_CORRECT_ON_FIELD = 2;
const TOTAL_ITEMS_ON_FIELD = 6;

/* =====================
   –ü–ï–†–ï–ú–ï–ù–ù–´–ï
===================== */

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let path = [];
let maxLength = 30;

let direction = { x: 1, y: 0 }; // –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è
let items = [];
let correctCount = 0;
let gameRunning = false;
let CONFIG = null;

/* =====================
   –ö–õ–ò–ö = –ù–ê–ü–†–ê–í–õ–ï–ù–ò–ï
===================== */

canvas.addEventListener("click", e => {
  if (!gameRunning) return;
  const r = canvas.getBoundingClientRect();
  const tx = e.clientX - r.left;
  const ty = e.clientY - r.top;

  const head = path[0];
  const dx = tx - head.x;
  const dy = ty - head.y;
  const d = Math.sqrt(dx*dx + dy*dy) || 1;

  direction = { x: dx/d, y: dy/d };
});

/* =====================
   –°–¢–ê–†–¢
===================== */

document.getElementById("startBtn").onclick = () => {
  CONFIG = {
    task: document.getElementById("taskInput").value,
    correct: document.getElementById("correctInput").value
      .split(",").map(s=>s.trim()).filter(Boolean),
    wrong: document.getElementById("wrongInput").value
      .split(",").map(s=>s.trim()).filter(Boolean)
  };

  document.getElementById("taskTitle").innerText = CONFIG.task;

  resetGame();
  gameRunning = true;
};

/* =====================
   –°–ü–ê–í–ù –≠–õ–ï–ú–ï–ù–¢–û–í
===================== */

function spawnItem(forceCorrect=false) {
  let pool;

  if (forceCorrect) {
    pool = CONFIG.correct.map(t=>({text:t, correct:true}));
  } else {
    pool = [
      ...CONFIG.correct.map(t=>({text:t, correct:true})),
      ...CONFIG.wrong.map(t=>({text:t, correct:false}))
    ];
  }

  const it = pool[Math.floor(Math.random()*pool.length)];

  items.push({
    ...it,
    x:Math.random()*560+20,
    y:Math.random()*360+20
  });
}

function ensureItems() {
  const correctOnField = items.filter(i=>i.correct).length;

  while (items.length < TOTAL_ITEMS_ON_FIELD) {
    spawnItem();
  }

  if (correctOnField < MIN_CORRECT_ON_FIELD) {
    spawnItem(true);
  }
}

/* =====================
   –î–í–ò–ñ–ï–ù–ò–ï (–ë–ï–ó –û–°–¢–ê–ù–û–í–ö–ò)
===================== */

function moveSnake() {
  if (!path.length) return;

  const head = path[0];
  const newHead = {
    x: head.x + direction.x * MOVE_SPEED,
    y: head.y + direction.y * MOVE_SPEED
  };

  path.unshift(newHead);
  while (path.length > maxLength) path.pop();
}

/* =====================
   –°–ê–ú–û–ü–ï–†–ï–°–ï–ß–ï–ù–ò–ï
===================== */

function checkSelfCollision() {
  const head = path[0];
  for (let i = 10; i < path.length; i++) {
    const dx = head.x - path[i].x;
    const dy = head.y - path[i].y;
    if (Math.sqrt(dx*dx + dy*dy) < 6) {
      gameRunning = false;
      showFail("–ó–º–µ–π–∫–∞ –∑–∞–ø—É—Ç–∞–ª–∞—Å—å üåÄ");
    }
  }
}

/* =====================
   –°–ë–û–†
===================== */

function checkItemCollision() {
  const head = path[0];

  items.forEach((item,i)=>{
    const dx=head.x-item.x;
    const dy=head.y-item.y;
    if (Math.sqrt(dx*dx+dy*dy) < 14) {
      if (item.correct) {
        correctCount++;
        maxLength += SEGMENT_STEP;
        showFeedback(true);
      } else {
        showFeedback(false);
      }
      items.splice(i,1);
    }
  });
}

/* =====================
   –ü–†–û–ì–†–ï–°–°
===================== */

function updateProgress() {
  const p = Math.min(correctCount / REQUIRED * 100, 100);
  document.getElementById("progress-bar").style.width = p + "%";
}

/* =====================
   –§–ò–î–ë–ï–ö
===================== */

function showFeedback(ok) {
  const f = document.getElementById("feedback");
  f.innerText = ok ? "–í–µ—Ä–Ω–æ!" : "–ü–æ–¥—É–º–∞–π –µ—â—ë";
  f.className = ok ? "success" : "error";
  setTimeout(()=>f.innerText="",600);
}

function showFail(text) {
  const f = document.getElementById("feedback");
  f.innerText = text;
  f.className = "fail";
}

/* =====================
   –û–¢–†–ò–°–û–í–ö–ê
===================== */

function draw() {
  ctx.clearRect(0,0,600,400);

  // —ç–ª–µ–º–µ–Ω—Ç—ã
  items.forEach(it=>{
    ctx.fillStyle = it.correct ? "#66bb6a" : "#cfd8dc";
    ctx.fillRect(it.x-8,it.y-8,16,16);
    ctx.fillStyle="#000";
    ctx.fillText(it.text,it.x-10,it.y-12);
  });

  // –∑–º–µ–π–∫–∞
  ctx.strokeStyle="#4caf50";
  ctx.lineWidth=6;
  ctx.beginPath();
  path.forEach((p,i)=>{
    if(i===0) ctx.moveTo(p.x,p.y);
    else ctx.lineTo(p.x,p.y);
  });
  ctx.stroke();
}

/* =====================
   –¶–ò–ö–õ
===================== */

function loop() {
  if (gameRunning) {
    moveSnake();
    checkItemCollision();
    checkSelfCollision();
    ensureItems();
    updateProgress();
  }
  draw();
  requestAnimationFrame(loop);
}

/* =====================
   –°–ë–†–û–°
===================== */

function resetGame() {
  path = [{ x:300, y:200 }];
  direction = { x:1, y:0 };
  maxLength = 30;
  correctCount = 0;
  items = [];
  document.getElementById("progress-bar").style.width="0%";
  ensureItems();
}

/* =====================
   –°–¢–ê–†–¢
===================== */

loop();
</script>

</body>
</html>
