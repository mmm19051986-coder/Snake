<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>–ó–º–µ–π–∫–∞ –∑–Ω–∞–Ω–∏–π</title>

<style>
  body {
    font-family: Arial, sans-serif;
    background: #f5f5f5;
  }

  #game-wrapper {
    width: 620px;
    margin: 20px auto;
    background: #fff;
    padding: 10px;
    border-radius: 10px;
  }

  #task {
    text-align: center;
    font-size: 18px;
    margin-bottom: 8px;
  }

  canvas {
    border: 2px solid #ddd;
    display: block;
    margin: auto;
  }

  #progress {
    height: 10px;
    background: #ddd;
    margin-top: 6px;
    border-radius: 5px;
    overflow: hidden;
  }

  #progress-bar {
    height: 100%;
    width: 0%;
    background: #4caf50;
    transition: width 0.3s;
  }

  #feedback {
    text-align: center;
    margin-top: 6px;
    font-weight: bold;
    min-height: 20px;
  }

  .success { color: green; }
  .error { color: orange; }
</style>
</head>

<body>

<div id="game-wrapper">
  <div id="task"></div>
  <canvas id="gameCanvas" width="600" height="400"></canvas>
  <div id="progress"><div id="progress-bar"></div></div>
  <div id="feedback"></div>
</div>

<script>
/* =====================
   –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ò–ì–†–´
   (–±—É–¥—É—â–∏–π —Ä–µ–¥–∞–∫—Ç–æ—Ä)
===================== */

const GAME_CONFIG = {
  taskText: "–°–æ–±–µ—Ä–∏ —Ç–æ–ª—å–∫–æ —Å—É—â–µ—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–µ",

  correctItems: [
    { label: "—Å—Ç–æ–ª" },
    { label: "–¥–æ–º" },
    { label: "–æ–∫–Ω–æ" }
  ],

  wrongItems: [
    { label: "–±–µ–∂–∞—Ç—å" },
    { label: "–∫—Ä–∞—Å–∏–≤—ã–π" }
  ],

  gameplay: {
    speed: 20,
    snakeGrowth: true,
    elementsOnField: 6,
    noPenaltyMode: true
  },

  progress: {
    requiredCorrect: 5
  },

  ui: {
    noTextMode: false
  },

  feedback: {
    successText: ["–í–µ—Ä–Ω–æ!", "–û—Ç–ª–∏—á–Ω–æ!", "–ú–æ–ª–æ–¥–µ—Ü!"],
    errorText: ["–ü–æ–ø—Ä–æ–±—É–π –µ—â—ë", "–ü–æ–¥—É–º–∞–π"]
  }
};

/* =====================
   –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
===================== */

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
document.getElementById("task").innerText = GAME_CONFIG.taskText;

let snake = [{ x: 100, y: 100 }];
let direction = { x: 20, y: 0 };
let items = [];
let correctCollected = 0;

/* =====================
   –£–ü–†–ê–í–õ–ï–ù–ò–ï
===================== */

document.addEventListener("keydown", e => {
  if (e.key === "ArrowUp") direction = { x: 0, y: -20 };
  if (e.key === "ArrowDown") direction = { x: 0, y: 20 };
  if (e.key === "ArrowLeft") direction = { x: -20, y: 0 };
  if (e.key === "ArrowRight") direction = { x: 20, y: 0 };
});

/* =====================
   –≠–õ–ï–ú–ï–ù–¢–´
===================== */

function spawnItems() {
  items = [];
  const all = [
    ...GAME_CONFIG.correctItems.map(i => ({ ...i, correct: true })),
    ...GAME_CONFIG.wrongItems.map(i => ({ ...i, correct: false }))
  ];

  for (let i = 0; i < GAME_CONFIG.gameplay.elementsOnField; i++) {
    const item = all[Math.floor(Math.random() * all.length)];
    items.push({
      ...item,
      x: Math.floor(Math.random() * 28) * 20,
      y: Math.floor(Math.random() * 18) * 20
    });
  }
}

/* =====================
   –§–ò–î–ë–ï–ö
===================== */

function showFeedback(success) {
  const box = document.getElementById("feedback");
  const texts = success
    ? GAME_CONFIG.feedback.successText
    : GAME_CONFIG.feedback.errorText;

  box.innerText = texts[Math.floor(Math.random() * texts.length)];
  box.className = success ? "success" : "error";

  setTimeout(() => box.innerText = "", 800);
}

/* =====================
   –ü–†–û–ì–†–ï–°–°
===================== */

function updateProgress() {
  const percent =
    (correctCollected / GAME_CONFIG.progress.requiredCorrect) * 100;

  document.getElementById("progress-bar").style.width = percent + "%";

  if (percent >= 100) {
    alert("üéâ –ó–∞–¥–∞–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ!");
    resetGame();
  }
}

/* =====================
   –°–¢–û–õ–ö–ù–û–í–ï–ù–ò–Ø
===================== */

function checkCollision() {
  const head = snake[0];

  items.forEach((item, index) => {
    if (head.x === item.x && head.y === item.y) {
      if (item.correct) {
        correctCollected++;
        showFeedback(true);
        if (GAME_CONFIG.gameplay.snakeGrowth) {
          snake.push({ ...snake[snake.length - 1] });
        }
      } else {
        showFeedback(false);
      }
      items.splice(index, 1);
    }
  });
}

/* =====================
   –û–¢–†–ò–°–û–í–ö–ê
===================== */

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // –∑–º–µ–π–∫–∞
  ctx.fillStyle = "green";
  snake.forEach(seg => ctx.fillRect(seg.x, seg.y, 18, 18));

  // —ç–ª–µ–º–µ–Ω—Ç—ã
  items.forEach(item => {
    ctx.fillStyle = item.correct ? "#4caf50" : "#999";
    ctx.fillRect(item.x, item.y, 18, 18);

    if (!GAME_CONFIG.ui.noTextMode) {
      ctx.fillStyle = "#000";
      ctx.fillText(item.label, item.x, item.y - 4);
    }
  });
}

/* =====================
   –ò–ì–†–û–í–û–ô –¶–ò–ö–õ
===================== */

function gameLoop() {
  const head = {
    x: snake[0].x + direction.x,
    y: snake[0].y + direction.y
  };

  snake.unshift(head);
  snake.pop();

  checkCollision();
  updateProgress();
  draw();
}

/* =====================
   –°–ë–†–û–°
===================== */

function resetGame() {
  snake = [{ x: 100, y: 100 }];
  correctCollected = 0;
  spawnItems();
}

/* =====================
   –°–¢–ê–†–¢
===================== */

spawnItems();
setInterval(gameLoop, GAME_CONFIG.gameplay.speed);

</script>

</body>
</html>
