<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>–ó–º–µ–π–∫–∞ –∑–Ω–∞–Ω–∏–π</title>

<style>
body { font-family: Arial, sans-serif; background:#f2f2f2; }

#game-wrapper {
  width: 680px;
  margin: 20px auto;
  background:#fff;
  padding:12px;
  border-radius:12px;
}

h2 { text-align:center; margin:6px 0; }

#editor {
  border:1px solid #ddd;
  padding:8px;
  margin-bottom:10px;
}

textarea {
  width:100%;
  height:60px;
  margin-bottom:6px;
}

select, button {
  padding:6px;
  margin-top:4px;
}

canvas {
  display:block;
  margin:auto;
  border:2px solid #ddd;
}

#progress { height:10px; background:#ddd; margin-top:8px; }
#progress-bar { height:100%; width:0%; background:#4caf50; }

#feedback { text-align:center; font-weight:bold; min-height:20px; }
.success { color:green; }
.error { color:orange; }
</style>
</head>

<body>

<div id="game-wrapper">
  <h2>–°–æ–±–µ—Ä–∏ —Ç–æ–ª—å–∫–æ —Å—É—â–µ—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–µ</h2>

  <!-- –†–ï–î–ê–ö–¢–û–† -->
  <div id="editor">
    <b>–ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ —Å–ª–æ–≤–∞ (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é)</b>
    <textarea id="correctInput">—Å—Ç–æ–ª, –¥–æ–º, –æ–∫–Ω–æ, –∫–Ω–∏–≥–∞</textarea>

    <b>–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ —Å–ª–æ–≤–∞</b>
    <textarea id="wrongInput">–±–µ–∂–∞—Ç—å, –∫—Ä–∞—Å–∏–≤—ã–π</textarea>

    <b>–£—Ä–æ–≤–µ–Ω—å —Å–ª–æ–∂–Ω–æ—Å—Ç–∏</b>
    <select id="level">
      <option value="easy">–õ—ë–≥–∫–∏–π</option>
      <option value="medium">–°—Ä–µ–¥–Ω–∏–π</option>
      <option value="hard">–°–ª–æ–∂–Ω—ã–π</option>
    </select>

    <br>
    <button id="startBtn">‚ñ∂ –ò–≥—Ä–∞—Ç—å</button>
  </div>

  <canvas id="gameCanvas" width="600" height="400"></canvas>

  <div id="progress"><div id="progress-bar"></div></div>
  <div id="feedback"></div>
</div>

<script>
/* =====================
   –£–†–û–í–ù–ò
===================== */

const LEVELS = {
  easy:   { speed:1.5, required:4, minItems:3 },
  medium: { speed:2.5, required:6, minItems:4 },
  hard:   { speed:3.5, required:8, minItems:5 }
};

/* =====================
   –ü–ï–†–ï–ú–ï–ù–ù–´–ï
===================== */

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let snake = [{ x:50, y:50 }];
let target = null;
let items = [];
let correctCount = 0;
let gameRunning = false;

let CONFIG = null;

/* =====================
   –ö–õ–ò–ö
===================== */

canvas.addEventListener("click", e => {
  if (!gameRunning) return;
  const r = canvas.getBoundingClientRect();
  target = { x:e.clientX-r.left, y:e.clientY-r.top };
});

/* =====================
   –°–¢–ê–†–¢ –ò–ó –†–ï–î–ê–ö–¢–û–†–ê
===================== */

document.getElementById("startBtn").onclick = () => {
  const correct = document.getElementById("correctInput").value
    .split(",").map(s=>s.trim()).filter(Boolean);

  const wrong = document.getElementById("wrongInput").value
    .split(",").map(s=>s.trim()).filter(Boolean);

  const levelKey = document.getElementById("level").value;
  CONFIG = { correct, wrong, ...LEVELS[levelKey] };

  resetGame();
  gameRunning = true;
};

/* =====================
   –≠–õ–ï–ú–ï–ù–¢–´
===================== */

function spawnItem() {
  const all = [
    ...CONFIG.correct.map(t=>({ text:t, correct:true })),
    ...CONFIG.wrong.map(t=>({ text:t, correct:false }))
  ];
  const it = all[Math.floor(Math.random()*all.length)];
  items.push({
    ...it,
    x:Math.random()*560+20,
    y:Math.random()*360+20
  });
}

function ensureItems() {
  while (items.length < CONFIG.minItems) spawnItem();
}

/* =====================
   –î–í–ò–ñ–ï–ù–ò–ï + –†–û–°–¢ x2
===================== */

function moveSnake() {
  if (!target) return;
  const head = snake[0];
  const dx = target.x-head.x;
  const dy = target.y-head.y;
  const d = Math.sqrt(dx*dx+dy*dy);
  if (d<2) return;

  snake.unshift({
    x:head.x+(dx/d)*CONFIG.speed,
    y:head.y+(dy/d)*CONFIG.speed
  });

  while (snake.length > Math.max(1, correctCount*2)) snake.pop();
}

/* =====================
   –°–ë–û–†
===================== */

function checkCollision() {
  const head = snake[0];
  items.forEach((item,i)=>{
    const dx=head.x-item.x;
    const dy=head.y-item.y;
    if (Math.sqrt(dx*dx+dy*dy)<14) {
      if (item.correct) {
        correctCount++;
        showFeedback(true);
      } else showFeedback(false);
      items.splice(i,1);
    }
  });
}

/* =====================
   –ü–†–û–ì–†–ï–°–°
===================== */

function updateProgress() {
  const p = Math.min(correctCount/CONFIG.required*100,100);
  document.getElementById("progress-bar").style.width=p+"%";
  if (p>=100) {
    alert("üéâ –£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω!");
    gameRunning=false;
  }
}

/* =====================
   –§–ò–î–ë–ï–ö
===================== */

function showFeedback(ok) {
  const f=document.getElementById("feedback");
  f.innerText=ok?"–í–µ—Ä–Ω–æ!":"–ü–æ–¥—É–º–∞–π –µ—â—ë";
  f.className=ok?"success":"error";
  setTimeout(()=>f.innerText="",600);
}

/* =====================
   –û–¢–†–ò–°–û–í–ö–ê
===================== */

function draw() {
  ctx.clearRect(0,0,600,400);

  items.forEach(it=>{
    ctx.fillStyle=it.correct?"#66bb6a":"#bdbdbd";
    ctx.fillRect(it.x-8,it.y-8,16,16);
    ctx.fillStyle="#000";
    ctx.fillText(it.text,it.x-10,it.y-12);
  });

  snake.forEach((s,i)=>{
    ctx.fillStyle=i==0?"#2e7d32":"#81c784";
    ctx.fillRect(s.x-8,s.y-8,16,16);
  });
}

/* =====================
   –¶–ò–ö–õ
===================== */

function loop() {
  if (gameRunning) {
    moveSnake();
    checkCollision();
    ensureItems();
    updateProgress();
  }
  draw();
  requestAnimationFrame(loop);
}

/* =====================
   –°–ë–†–û–°
===================== */

function resetGame() {
  snake=[{x:50,y:50}];
  items=[];
  target=null;
  correctCount=0;
  document.getElementById("progress-bar").style.width="0%";
  ensureItems();
}

/* =====================
   –°–¢–ê–†–¢
===================== */

loop();
</script>

</body>
</html>
